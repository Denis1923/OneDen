<!DOCTYPE html>
</html lang="ru"> <!-- обычно добавляют атрибут lang (language), в котором задаётся язык документа. Наш сайт будет русскоязычным, поэтому lang ="ru" -->
	<head>
		<link href="style_teacher.css" rel="stylesheet"> <!-- У <link> в атрибуте href задаётся адрес стилевого файла, а атрибут rel со значением stylesheet говорит браузеру, что мы подключаем именно стили, а не что-то другое -->
		<title>Заголовок</title>
		<meta charset="название кодировки">
		<meta name="keywords" content="Важные, ключевые, слова">
		<meta name="description" content="краткое описание">
		<script src="имя_файла.js"></script>
	</head>

	<body>
		<header>
				<h1>Шпаргалка</h1>
		</header>
		<main>
			<h2>HTML5</h2>
			<dl>
				<dt>header</dt>
				<dd>Хедер — это не только привычная шапка сайта с логотипом и меню,
					он может использоваться и как «шапка» какой-нибудь статьи или раздела сайта.
					Конечно, в этом случае хедер называют не «шапкой», а вводной частью, в которой
					 могут содержаться заголовки, оглавление и так далее.
					 А раз теги не уникальные, то и стилизовать их лучше с помощью классов, как мы и сделали.

					 Если вы не хотите использовать классы для шапки и подвала сайта, то можете использовать селекторы body > header.
					 Эти селекторы не повлияют на хедеры и футеры, вложенные более глубоко.
				</dd>
				<dt>footer</dt>
				<dd>С футером ситуация аналогичная. В привычном нам понимании это «подвал» сайта, с копирайтами,
					контактной информацией и так далее. Но футер может использоваться и в других разделах сайта.
					 Например, в футере статьи можно разместить дополнительную информацию: данные об авторе,
					 дополнительные ссылки и так далее.

					 Если вы не хотите использовать классы для шапки и подвала сайта, то можете использовать селекторы
					  body > footer.
					 Эти селекторы не повлияют на хедеры и футеры, вложенные более глубоко.
				</dd>
			</dl>
			<p>Разметим разделы «Обо мне» и «Последние посты». Используем для этого теги &lt;section&gt; и &lt;article&gt;:</p>
				<ul>
					<li>&lt;section&gt; — смысловой или логический раздел документа;</li>
				<li>&lt;article&gt; — самостоятельный и независимый раздел документа.</li>
			</ul>
				<p>Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:</p>
				<ul>
					<li>&lt;div&gt; — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.</li>
						<li>&lt;section&gt; — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.</li>
							<li>&lt;article&gt; — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах.
								Примеры: статья, пост в блоге, сообщение на форуме и так далее.</li>
			</ul>

			<h2>article</h2>
			<p>
				Пост — это цельный, законченный и самостоятельный фрагмент информации. Для его разметки идеально подойдёт тег article.

					Так как article должен быть независимым, то при разметке удобно считать его отдельной и самостоятельной страницей сайта.
						При этом иерархия заголовков на всей нашей странице должна быть «сквозная», то есть внутри article заголовок
							 будет «очередного» уровня. Заголовок родительского раздела section у нас второго уровня — h2,
								  значит внутри article нужен заголовок третьего уровня — h3.
			</p>

			<p>
				в HTML есть специальный элемент для навигационных блоков — тег &lt;nav&gt;.
					Так что меню и блоки ссылок лучше оборачивать не в дивы, а в навы.<br>
					В случае, когда навигация шапки дублируется в подвале сайта,
					не рекомендуется использовать тег &lt;nav&gt повторно. Достаточно будет использовать список со ссылками.
			</p>

			<h2>Шрифт</h2>
			<p>
				При использовании веб-шрифтов не забывайте указывать так называемые
				«фоллбэк»-шрифты — стандартные шрифты, которые будут отображаться,
				если веб-шрифт либо недоступен, либо не поддерживается старым браузером пользователя.
				Для этого нужно всего лишь перечислить их через запятую после нестандартного шрифта:<br>
				font-family: "PT Sans", "Arial", sans-serif;
			</p>

			<p>Технически подключение веб-шрифтов производится с помощью CSS-правила @font-face. Читается как «эт-правило font-face». Вот пример:
			</p>
			<p><i>
				@font-face {<br>
					font-family: "Roboto";<br>
					src:<br>
						local("Roboto Regular"),<br>
						url("roboto.woff") format("woff");<br>
					}</i>
			</p>

				<p>В этом правиле вы указываете название шрифта, которое будете использовать в font-family и источники, из
				которых браузер сможет загрузить шрифт. Обычно сначала указывают название шрифта в системе, чтобы браузер
				попытался найти его локально на компьютере пользователя, а затем указывают адрес файла шрифта в интернете.</p>

				<p>Более подробно о технических тонкостях подключения шрифтов можно прочитать в серии статей на fontstorage:
				первая часть и вторая часть.</p>
				<p>Получается, что можно хранить шрифты и подключать их со своего сервера. Это особенно полезно, когда шрифт
				 очень редкий и его нет ни в одном из шрифтовых сервисов. В этом случае поступают так:</p>
				<ol>
					<li> Берут файл шрифта (например, .ttf) и конвертируют в веб-формат в сервисе наподобие Font Squirrel
						(для кириллических шрифтов надо указать дополнительные параметры конвертации).</li>
						<li>Затем сконвертированные файлы шрифта размещают у себя на сервере.</li>
						<li>И подключают шрифт с помощью @font-face.</li>
				</ol>

				<p>
					&lt;aside&gt; — это дополнительное содержание, не связанное напрямую с основным. Ещё такие блоки часто называют «сайдбарами» или боковыми панелями.
				</p>

				<p>Специфичность селектора разбивается на 4 группы — a, b, c, d:</p>
				<ul>
					<li>если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;</li>
					<li>значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе;</li>
					<li>значение c равно количеству классов, псевдоклассов и селекторов атрибутов;</li>
					<li>значение d равно количеству селекторов типов элементов и псевдо-элементов.</li>
				</ul>





	<h2>Списки</h2>wi
		<h2>Маркированый список</h2>
		<ul start="2">
			<li >h1</li>
			<li>h2</li>
			<li>h3</li>
		</ul>
		<h2>Пронумерованный список</h2>
		<ol start="2">
			<li >h1</li>
			<li>h2</li>
			<li>h3</li>
		</ol>
		<h2>Многоуровневый список</h2>
		<ul>
		  <li>1
			<ul>
			  <li>1.1</li>
			  <li>1.2</li>
			</ul>
		  </li>
		  <li>2</li>
		</ul>

		<p>
			<strong>ol</strong><br>
			По умолчанию нумерация пунктов начинается с единицы, а с помощью start можно поменять это стартовое число.<br>
			Атрибут reversed меняет направление нумерации на противоположный. Этот атрибут не требует значения<br>
			С помощью ещё одного атрибута, type, можно задавать различные типы маркеров, вместо обычных арабских цифр:
			строчные и заглавные латинские буквы или римские цифры. Возможные значения этого атрибута:</p>
				<ul>
					<li>1: десятичное число;</li>
					<li>a: буквы латинского алфавита в нижнем регистре;</li>
					<li>A: буквы латинского алфавита в верхнем регистре;</li>
					<li>i: римские цифры в нижнем регистре;</li>
					<li>I: римские цифры в верхнем регистре.</li>
				</ul>
			<p>
				Теги <strong>ol</strong> и <strong>ul</strong> можно вкладывать друг в друга и создавать многоуровневые списки. Количество уровней в списках не ограничено.
			</p>

		<h2>Спимок терминов</h2>
		<dl>
			<dt>blockquote</dt>
			<dd>предназначен для выделения длинных цитат, которые могут состоять из нескольких абзацев. Тег выделяет цитату как отдельный блок текста с отступами.</dd>

			<dt>q</dt>
			<dd>предназначен для выделения коротких цитат в предложениях. Текст внутри этого тега автоматически обрамляется кавычками.</dd>

			<dt>cite</dt>
			<dd>используется для того, чтобы выделить источник цитаты, название произведения или автора цитаты</dd>

			<dt>sup</dt>
			<dd>отображает текст в виде верхнего индекса</dd>

			<dt>sub</dt>
			<dd>отображает текст в виде нижнего индекса</dd>

			<dt>del</dt>
			<dd>выделяет текст, который был удалён в новой версии документа + атрибут datetime</dd>

			<dt>ins</dt>
			<dd>выделяет текст, который был добавлен в новой версии документа + атрибут datetime</dd>

			<dt>pre</dt>
			<dd>«предварительно отформатированный текст». Браузер сохраняет и отображает все пробелы и переносы, которые есть внутри тега</dd>

			<dt>mark</dt>
			<dd>В HTML5 появился новый тег, который обозначает выделенный текст (желтым).</dd>

			<dt>Атрибут alt</dt>
			<dd>Если у пользователя отключены изображения или их невозможно загрузить, то в браузере отображается альтернативный текст. </dd>

			<dt>table</dt>
			<dd>обозначает таблицу.</dd>

			<dt>tr</dt>
			<dd>расшифровывается как «table row», обозначает строку таблицы</dd>

			<dt>td</dt>
			<dd>расшифровывается как «table data», обозначает ячейку внутри строки таблицы</dd>

			<dt>th</dt>
			<dd>расшифровывается как «table header» и обозначает ячейку-заголовок.</dd>

			<dt>caption</dt>
			<dd>Распределение браузеров сделана с помощью заголовка первого уровня. В принципе, можно догадаться, что это название таблицы, но семантически правильнее будет сделать это название с помощью тега <strong>caption</strong>.<br>
				По вертикали заголовок таблицы перемещается CSS-свойством caption-side со значениями top и bottom, которые обозначают до и после таблицы соответственно.
				<br>
				По горизонтали заголовок таблицы выравнивается CSS-свойством text-align со значениями left, right и center.</dd>

			<dt>colspan</dt>
			<dd>Чтобы объединить ячейки по горизонтали, необходимо использовать атрибут colspan у тегов <strong>th</strong> или <strong>td</strong>.</dd>

			<dt>rowspan</dt>
			<dd>Чтобы объединить ячейки по вертикале, необходимо использовать атрибут colspan у тегов <strong>th</strong> или <strong>td</strong>.</dd>

			<dt>form</dt>
			<dd>У тега <strong>form</strong> есть два важных атрибута: action задаёт адрес, URL, отправки формы; method задаёт метод отправки формы:<br>
				Метод <strong>get</strong> лучше использовать в поисковых формах, потому что он позволяет получить ссылку на результаты поиска и передать её кому-то.
				<br>
				Метод <strong>post</strong> посылает данные в теле HTTP-запроса и используется, когда нужно отправить много данных и ссылка на результат обработки этих данных не нужна. Например, при редактировании личного профиля.<br>
				Если не указать атрибут method, то будет использован get.</dd>

			<dt>textarea</dt>
			<dd>У него есть атрибуты name и id, которые аналогичны атрибутам текстового поля.
				<br>
				Атрибут rows принимает целочисленное значение и задаёт высоту многострочного поля в строках. Атрибут cols задаёт ширину поля в символах. В качестве ширины символа берётся некоторая «усреднённая ширина».
				<br>
				Атрибут value у многострочного поля отсутствует, а значение по умолчанию задаётся по-другому. Текст, расположенный между открывающим и закрывающим тегом <strong>textarea</strong> и является значением по умолчанию. Вот так:</dd>
			<dt>code</dt>
			<dd>Для обозначения фрагментов кода есть специальный тег.  Стиль также можно задавать. Можно комбинировать,  Тег <strong>code</strong> можно вкладывать внутрь тега <strong>pre</strong>, а наоборот делать нельзя. </dd>

			<dt>time</dt>
			<dd>С помощью <strong>time</strong> можно описывать даты одновременно и для человека, и для машины. Дата для человека описывается внутри тега, а дата для машины — внутри атрибута datetime в формате ISO 8601:	</dd>
			<pre>
				<code>
					<time datetime="2016-11-18T09:54">09:54 утра</time>
					<time datetime="2015-11-18">18 ноября 2015</time>
					<time datetime="2018-09-23">в прошлую субботу</time>
					<time datetime="2017-04-20">вчера</time>
				</code>
			</pre>

			<dt>em</dt>
			<dd>определяет текст, на который сделан особый акцент, меняющий смысл предложения.</dd>

			<dt>i</dt>
			<dd>применяется для обозначения текста, который отличается от окружающего текста, но не является более важным.
				Например, в <strong>i</strong> можно заключать названия, термины, иностранные слова.
				Также в этот тег можно обернуть мысли героя. В речи такой текст обычно выделяется интонационно.</dd>

			<dt>div, span</dt>
			<dd>Тег <strong>div</strong> обычно используется для группировки крупных элементов, например, нескольких абзацев, или в качестве контейнера для создания сеток страниц.
			А <strong>span</strong> используется для выделения мелких текстовых элементов: частей слов, отдельных слов или фраз, состоящих из нескольких слов</dd>

			<dt>атрибут download</dt>
			<dd>Для того чтобы предотвратить открытие файлов прямо в браузере, у тега <strong>a</strong> существует атрибут <strong>download</strong>, который поможет именно скачать файл.</dd>

			<dt>формат SVG</dt>
			<dd>SVG (Scalable Vector Graphics) переводится как масштабируемая векторная графика.
			Качество таких изображений не меняется при изменении размеров, да и вес у них небольшой.
			Формат SVG отлично подходит для малоцветных схем, логотипов и иконок.<br>
			То есть, формат SVG подходит если:<br>
			- необходимо масштабировать изображение без потерь;<br>
			- изменять цвет элементов изображения;<br>
			- нужно анимировать части изображения.
			</dd>

			<dt>формат JPEG</dt>
			<dd>Этот формат был разработан для сжатия и хранения полноцветных фотографий.
			Он поддерживает более 16 миллионов цветов. Но нужно помнить, что JPEG сжимает изображения с потерей качества.
			Поэтому если мы хотим уменьшить вес изображения, то придётся ухудшать её внешний вид.
			Главная задача при работе с JPEG — подобрать такой уровень сжатия, чтобы и вес, и качество картинки были приемлемыми.<br>
				Таким образом, формат JPEG лучше подходит для:<br>
				- полноцветных изображений, фотографий;<br>
				- изображений с плавным переходом яркости и контраста;<br>
				- рисунков с большим количеством разноцветных деталей.</dd>

			<dt>формат PNG</dt>
			<dd>В отличие от JPEG, PNG является форматом сжатия без потерь и позволяет сохранять изображения, в которых требуется особенная чёткость.
			Например, скриншоты сайтов, чертежи и печатный текст. Главная особенность формата PNG — поддержка прозрачности, то есть каждому пикселю в
			отдельности можно задать свою степень прозрачности.<br>
				Итак, формат PNG подходит для:<br>
				- изображений с прозрачностью и полупрозрачностью;<br>
				- полноцветных изображений, когда необходима повышенная точность;<br>
				- изображений с резкими переходами цветов.</dd>

			<dt></dt>
			<dd>Этот тег хорош для любого иллюстративного или демонстрационного материала, которым можно дополнить содержание документа.
			Таким материалом могут быть схемы, графики, примеры кода, таблицы и так далее. При удалении иллюстративного материала основное
			содержание не должно пострадать, иначе это уже не дополнительный материал и тег <strong>figure</strong> не очень подходит для его разметки.<br>
				&lt;figure&gt;<br>
			  Схема, график, диаграмма или код<br>
			  	&lt;figcaption&gt;Подпись к содержимому	&lt;/figcaption&gt;<br>
				&lt;/figure&gt;<br>
			</dd>


			<h4>CSS-свойство</h4>
			<dt>text-align</dt>
			<dd>За выравнивание по горизонтали отвечает CSS-свойство text-align. Чаще всего используются значения left, center и right.</dd>

			<dt>vertical-align</dt>
			<dd>За выравнивание по вертикали отвечает CSS-свойство vertical-align. Чаще всего используются значения top, middle и bottom.</dd>

			<dt>CSS-правил (rule sets)</dt>
			<dd>Помимо CSS-правил (rule sets) в языке существуют так называемые «эт-правила» (at-rules), они начинаются с символа @,
			например, @font-face. «Эт-правила» ещё называют CSS-директивами.</dd>

			<dt></dt>
			<dd>Абсолютные единицы измерения привязаны к настоящим физическим размерам и связаны между собой жёсткими пропорциями. Примеры абсолютных единиц измерения:</dd>

			<dt></dt>
			<dd>Относительные единицы измерения описывают значения, которые зависят от других значений. Например, ширина элемента в процентах зависит от ширины родительского элемента,
			а ширина элемента в em зависит от размера шрифта самого элемента.</dd>

			<dt>Величина 1em</dt>
			<dd>это такой же размер шрифта, что и у родителя. Соответственно, если мы хотим, чтобы шрифт дочернего элемента был всегда в 2 раза больше родительского, то зададим значение 2em:</dd>

			<dt>font-family.</dt>
			<dd>
				serif — шрифт с засечками;<br>
				sans-serif — шрифт без засечек.<br>
				monospace — моноширинный шрифт;<br>
				cursive — шрифт с неформальным начертанием, например, имитация рукописного текста или леттеринга;<br>
				fantasy — декоративный шрифт, например, всемирно известный Comic Sans.
			</dd>

			<dt>font-weight </dt>
			<dd>
				100: Thin;<br>
				200: Extra Light (Ultra Light);<br>
				300: Light;<br>
				400: Normal;<br>
				500: Medium;<br>
				600: Semi Bold (Demi Bold);<br>
				700: Bold;<br>
				800: Extra Bold (Ultra Bold);<br>
				900: Black (Heavy).<br>
				Все эти числовые значения задают степень толщины шрифта от самого тонкого до самого толстого.
			</dd>

			<dt>vertical-align</dt>
			<dd>
				top — выравнивание по верхнему краю строки;<br>
				middle — по середине строки;<br>
				bottom — по нижнему краю строки;<br>
				baseline — по базовой линии строки (значение по умолчанию).
			</dd>

			<dt>За отступы в CSS отвечают два свойства:</dt>
			<dd>padding задаёт внутренние отступы в блоке, а margin задаёт внешние отступы.</dd>

			<dt>white-space</dt>
			<dd>
				nowrap — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;<br>
				pre — сохраняет пробелы и переносы как в исходном коде аналогично тегу <strong>pre</strong>;<br>
				pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;<br>
				normal — режим по умолчанию: лишние пробелы и переносы строк схлопываются, текст переносится, пробелы в конце строк удаляются.<br>
				break-spaces — поведение идентично pre-wrap, но при схлопывании пробелов остаются нетронутыми зарезервированные пробелы, такие как пробелы в конце строки;<br>
				pre-line — как normal, но лишние пробелы схлопываются, строки переносятся на символе переноса строки, на <strong>br</strong> и по мере заполнения строки.
			</dd>

			<dt>text-decoration</dt>
			<dd>
				nderline — подчёркивание;<br>
				line-through — зачёркивание;<br>
				overline — надчёркивание;<br>
				none — убирает вышеперечисленные эффекты.<br>

				Свойство text-decoration — составное, а это значит, что его можно разложить на следующие свойства:<br>
					text-decoration-line — вид линии: зачёркивание, подчёркивание или надчёркивание;<br>
					text-decoration-style — стиль линии, может принимать значения:<br>
					solid — сплошная линия;<br>
					double — двойная линия;<br>
					dotted — точечная линия;<br>
					dashed — пунктирная линия;<br>
					wavy — волнистая линия.<br>
					text-decoration-color — цвет линии.<br>
			</dd>

			<dt>text-transform</dt>
			<dd>
				lowercase — все строчные;<br>
				uppercase — все заглавные;<br>
				capitalize — каждое слово начинается с большой буквы;<br>
				none — отменяет изменение регистра.
			</dd>

			<dt>Приоритеты каскадной стилистики</dt>
			<dd>CSS-правила в значении атрибута style самые приоритетные,<br>
					за ними идёт селектор с id,<br>
					затем селектор с классом,<br>
					затем селектор с именем тега.<br>
					 Если селекторы однотипные, как в нашем случае, то тогда более приоритетным является CSS-правило, которое расположено ниже в коде.
				</dd>

			<dt>варинаты подключения стилей</dt>
			<dd>
				/* выбрать все теги strong внутри тегов p */<br>
				p strong { ... }<br>
				/* выбрать все элементы с классом .hit внутри тегов ul */<br>
				ul .hit { ... }<br>
				выбрать все ссылки внутри элементов с классом .menu,<br>
		   которые лежат внутри элементов с классом .footer<br>
			 	.footer .menu a { ... }
			</dd>

			<dt>Соседние селекторы</dt>
			<dd>
				Соседние селекторы записываются с помощью знака +, например, селектор1 + селектор2.<br>
				Стили применятся к элементу, подходящему под селектор2, только если сразу перед ним
				расположен элемент, подходящий под селектор1.<br>
				Пример<br>
				Селектор .hit + .miss применит стили к элементу с классом miss, так как перед ним есть элемент с классом hit.<br>
				Селектор .hit + li, а также селектор li + .miss, или даже li + li тоже применит стили к элементу с классом
				miss, то есть ко второму элементу списка.<br>
				А вот селектор .miss + .hit не сработает, так как элемент с классом miss находится после элемента с классом
				hit в разметке.
			</dd>

			<dt>Дочерние селекторы</dt>
			<dd>
				Контекстные селекторы влияют на всех потомков, что не всегда удобно.
				Иногда необходимо задать стили только для дочерних элементов.
				Особенно это полезно при работе с многоуровневыми списками. <br>
				Для этого существует дочерний селектор, в котором используется символ >. <br>
				Например: <br>
				ul > li или ul > li > span.
			</dd>

			<dt>Дочерние классы</dt>
			<dd>
				Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:<br>
				&lt;ul&gt;<br>
				&lt;li&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt;<br>
				&lt;li&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt;<br>
				&lt;/ul&gt;<br>
				По отношению к списку &lt;ul&gt; элементы &lt;li&gt; являются дочерними элементами и потомками, а &lt;span&gt; — потомки, но не дочерние элементы.<br>
				Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.<br>
				Для этого существует дочерний селектор, в котором используется символ >. Например: ul > li или ul > li > span.

			</dd>

			<dt>Псевдоклассы</dt>
			<dd>
				Псевдоклассы — это дополнения к обычным селекторам, которые делают их ещё точнее и мощнее.
				Обычный селектор — это снайперский прицел, а с псевдоклассом он становится прибором ночного видения.<br>
 	 			Псевдокласс добавляется к селектору c помощью символа :, вот так <strong>селектор:псевдокласс.</strong><br>
				Псевдокласс:<br>
				first-child - позволяет выбрать первый дочерний элемент родителя<br>
				last-child — последний дочерний элемент.<br>
				:link выбирает ещё не посещённые ссылки.<br>
				:visited выбирает посещённые ссылки.<br>
				:active выбирает активные ссылки (кнопка мыши зажата на ссылке).<br>
				:focus позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе.<br>
				В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.<br>
				nth-child - можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: селектор:nth-child(выражение). Выражением может быть число или формула.<br>
				li:nth-child(2) { ... } — второй элемент списка<br>
				li:nth-child(4) { ... } — четвёртый элемент списка<br>
				li:nth-child(2n) { ... } — все чётные элементы
			</dd>

			<dt>Динамические эффекты с помощью :hover</dt>
			<dd>
				Интересовались ли вы, как с помощью CSS создаются выпадающие меню?<br>
				Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются <br>
				на несколько псевдоклассов, главный из которых, конечно же, :hover. <br>
				Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:<br>
					li.top ul.submenu {	display: none;	}<br>
					li.top:hover ul.submenu { display: block; }<br>
				Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, <br>
				наведут курсор, то надо показать подменю». Вот так всё просто.<br>
				Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. <br>
				То есть всё работает на контекстных селекторах вида селектор1:hover селектор2.
			</dd>

			<dt>Селекторы атрибутов</dt>
			<dd>
			Ранее мы познакомились с атрибутом class и специальными селекторами по классу. Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.<br>
			Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.<br>
			Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:<br>
				input[checked] { ... }<br>
				input[type="text"] { ... }<br>
			Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.
			</dd>

			<dt>Селектор по id</dt>
			<dd>Использование селекторов по id при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.</dd>

			<dt>Наследуемые свойства</dt>
			<dd>
				К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста:<br>
				font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и т. д.<br>
				Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.
			</dd>

			<dt>Ненаследуемые свойства</dt>
			<dd>
				 background, border, padding, margin, width, height, position и др.
			</dd>

			<dt>Принудительное наследование</dt>
			<dd>
				Для каждого свойства может быть задано значение inherit.<br>
				Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента.
				Значение inherit может быть использовано для усиления наследуемых значений,
				а также в свойствах, которые обычно не наследуются.
			</dd>

			<dt>Каскадирование</dt>
			<dd>
				Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств). <br>
				Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, <br>
				каким будет финальный набор свойств элемента.<br>
				Селекторы у правил одинакового типа, и соответственно обладают одинаковой специфичностью. <br>
				В таком случае более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже<br>
				p.blue { color: blue;}<br>
				.red { color: red;}<br>
				В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red.<br>
				Особенность атрибута id заключается в том, что его значение должно быть уникальным в пределах страницы. То есть, может существовать
				только один тег с определённым значением id.<br>
				Получается, что селектор по id может выбрать только один элемент. И поэтому он на порядок специфичнее селекторов по тегам,
				классам, а также комбинаций этих селекторов.<br>
				CSS-правила, которые прописаны в style обладают наивысшим приоритетом. Такой способ задания стилей не приветствуется в
				профессиональной вёрстке сайтов и годится только для создания быстрых прототипов. Поэтому мы и назвали этот приём запрещённым.<br>
				Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. <br>
				Для этого нужно использовать ключевое слово !important. Оно задаёт CSS-свойству усиленный приоритет. Вот пример:<br>
				HTML:	&lt;p style="color: red;" class="blue"&gt;Синий или красный?&lt;/p&gt;<br>
				CSS: .blue { color: blue !important;}<br>
				Цвет текста в этом примере будет синим.
			</dd>

			<dt>Расчёт значения специфичности</dt>
			<dd>
				Вы вдоволь наигрались со специфичностью, а теперь пришло время изучить полные правила её вычисления.<br>
				Специфичность селектора разбивается на 4 группы — a, b, c, d:<br>
				если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;<br>
				значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе;<br>
				значение c равно количеству классов, псевдоклассов и селекторов атрибутов;<br>
				значение d равно количеству селекторов типов элементов и псевдо-элементов.<br>
				После этого полученное значение приводится к числу (обычно в десятичной системе счисления).
				Селектор, обладающий большим значением специфичности, обладает и большим приоритетом.<br>
				Посчитаем специфичность в нашем примере:
				<table>
					<tr>
							<th>Селектор</th><th>a, b, c, d</th><th>Число</th>
					</tr>
					<tr>
							<td>span</td><td>0, 0, 0, 1</td><td>1</td>
					</tr>
					<tr>
							<td>div.cat-in-box</td><td>0, 0, 1, 1	</td><td>11</td>
					</tr>
					<tr>
							<td>#floor.cat-in-box</td><td>0, 1, 1, 0</td><td>110</td>
					</tr>
					<tr>
							<td>div span</td><td>0, 0, 0, 2</td><td>2</td>
					</tr>
					<tr>
							<td>.cat-in-box</td><td>0, 0, 1, 0</td><td>10</td>
					</tr>
					<tr>
							<td>#floor span</td><td>0, 1, 0, 1</td><td>101</td>
					</tr>
				</table>
			</dd>

			<dt></dt>
			<dd></dd>

			<dt></dt>
			<dd></dd>

			<dt></dt>
			<dd></dd>

			<dt></dt>
			<dd></dd>

			<dt></dt>
			<dd></dd>

			<dt></dt>
			<dd></dd>

			<dt></dt>
			<dd></dd>
		</dl>

		<h2>Ссылки</h2>

		<p>Абсолютные адреса содержат минимум три части: протокол, имя сервера и путь.</p>
		<pre>
			https:           — протокол
			//site.ru        — имя сервера
			/blog/index.html — путь
		</pre>
		<p>Если в адресе нет имени сервера или протокола, то это относительный адрес:</p>
			<pre>
			https://site.ru/blog/index.html - абсолютный адрес
				//site.ru/blog/index.html - относительный адрес
               /blog/index.html - относительный адрес
                     index.html - относительный адрес
			</pre>

		<h2>Якоря</h2>
		<p>Ссылка с якорем содержит символ #, после которого идёт идентификатор. Идентификатор создаётся с помощью атрибута id, который может быть задан у любого тега</p>
		<p>Для того чтобы добавить ссылке всплывающую подсказку, надо использовать атрибут title. Пример <strong>title="подсказка".</strong></p>

		<h2>Пример как можно сделать ссылку</h2>
		<pre> a href="img.jpg"
		img src="img-small.jpg"</pre>

		<pre>
			a href="http://keksby.ru"
				img src="cat.png" alt="Кекс"
			/a
		</pre>

		<h2>Таблица</h2>
		<table border="1">
			  <caption>Распределение браузеров</caption>
			  <tr>
				<th rowspan="2">Браузер</th>
				<th colspan="2">Посещения</th>
			  </tr>
			  <tr>
				<th>Количество</th>
				<th>В процентах</th>
			  </tr>
			  <tr>
				<td>Mozilla Firefox</td>
				<td>1263</td>
				<td>75%</td>
			  </tr>
			  <tr>
				<td>Google Chrome</td>
				<td>78</td>
				<td>5%</td>
			  </tr>
			  <tr>
				<td>Safari</td>
				<td>345</td>
				<td>20%</td>
			  </tr>
			</table>

			<h2>Формы</h2>
			<form action="https://echo.htmlacademy.ru/courses" method="post">
				  <label for="login-id">Ваш логин (email):</label><br>
				  <input  type="text" name="" id="login-id" required><br>
				  <label for="pass-id">Пароль: </label><br>
				  <input type="password" name="" id="pass-id"><br>
				  <label for="area-id">Информация о себе:  </label><br>
				  <textarea rows="3" id="area-id">Подпись </textarea><br>
				  <input type="checkbox" id="check-id" checked>
				  <label for="check-id">Подписаться на рассылку</label><br>
					<input type="text" list="browsers" name="browser">
					<datalist id="browsers">
					  <option value="Firefox"></option>
					  <option value="Chrome"></option>
					  <option value="Safari"></option>
					</datalist>
				  <input type="submit" id="submit" value="Зарегистрироваться">
				</form>
			</main>
</body>
</html>
